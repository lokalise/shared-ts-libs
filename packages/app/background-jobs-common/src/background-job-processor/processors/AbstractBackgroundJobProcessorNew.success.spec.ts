import { generateMonotonicUuid } from '@lokalise/id-utils'
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'
import { z } from 'zod'
import { TestDependencyFactory } from '../../../test/TestDependencyFactory.ts'
import { TestSuccessBackgroundJobProcessorNew } from '../../../test/processors/TestSuccessBackgroundJobProcessorNew.ts'
import type { FakeQueueManager } from '../managers/FakeQueueManager.ts'
import type { QueueConfiguration } from '../managers/types.ts'
import { FakeBackgroundJobProcessorNew } from './FakeBackgroundJobProcessorNew.ts'
import type { BackgroundJobProcessorDependenciesNew } from './types.ts'

const supportedQueues = [
  {
    queueId: 'queue1',
    jobPayloadSchema: z.object({
      id: z.string(),
      value: z.string(),
      metadata: z.object({
        correlationId: z.string(),
      }),
    }),
  },
  {
    queueId: 'queue2',
    jobPayloadSchema: z.object({
      id: z.string(),
      value2: z.string(),
      metadata: z.object({
        correlationId: z.string(),
      }),
    }),
  },
] as const satisfies QueueConfiguration[]

type SupportedQueues = typeof supportedQueues

describe('AbstractBackgroundJobProcessorNew - success', () => {
  let factory: TestDependencyFactory
  let deps: BackgroundJobProcessorDependenciesNew<SupportedQueues, 'queue1' | 'queue2'>

  let simpleProcessor: FakeBackgroundJobProcessorNew<SupportedQueues, 'queue1'>
  let processorWithSuccessHook: TestSuccessBackgroundJobProcessorNew<SupportedQueues, 'queue2'>
  let queueManager: FakeQueueManager<SupportedQueues>

  beforeEach(async () => {
    factory = new TestDependencyFactory()
    deps = factory.createNew(supportedQueues)
    queueManager = deps.queueManager

    await factory.clearRedis()

    simpleProcessor = new FakeBackgroundJobProcessorNew<SupportedQueues, 'queue1'>(deps, 'queue1')
    await simpleProcessor.start()
    processorWithSuccessHook = new TestSuccessBackgroundJobProcessorNew<SupportedQueues, 'queue2'>(
      deps,
      'queue2',
    )
    await processorWithSuccessHook.start()
  })

  afterEach(async () => {
    await simpleProcessor.dispose()
    await processorWithSuccessHook.dispose()
    await factory.dispose()
  })

  it('runs the job with autogenerated id', async () => {
    // Given
    const jobData = {
      id: generateMonotonicUuid(),
      value: 'test',
      metadata: { correlationId: generateMonotonicUuid() },
    }

    // When
    const jobId = await queueManager.schedule('queue1', jobData)

    // Then
    const UUID_REGEX =
      /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/
    expect(UUID_REGEX.test(jobId)).toBe(true)

    const job = await simpleProcessor.spy.waitForJobWithId(jobId, 'completed')
    expect(job.data).toMatchObject(jobData)

    const resolvedJob = await queueManager.getQueue('queue1').getJob(job.id!)
    expect(resolvedJob!.data).toMatchObject(jobData)

    // @ts-expect-error executing protected method for testing
    expect(simpleProcessor.worker.isRunning()).toBe(true)
  })

  it('schedules and runs multiple jobs', async () => {
    // Given - When
    const scheduledJobIds = await queueManager.scheduleBulk('queue1', [
      {
        id: generateMonotonicUuid(),
        value: 'first',
        metadata: { correlationId: generateMonotonicUuid() },
      },
      {
        id: generateMonotonicUuid(),
        value: 'second',
        metadata: { correlationId: generateMonotonicUuid() },
      },
    ])

    // Then
    expect(scheduledJobIds.length).toBe(2)

    const firstJob = await simpleProcessor.spy.waitForJobWithId(scheduledJobIds[0], 'completed')
    const secondJob = await simpleProcessor.spy.waitForJobWithId(scheduledJobIds[1], 'completed')

    expect(firstJob.data.value).toBe('first')
    expect(secondJob.data.value).toBe('second')
  })

  it('should trigger onSuccess hook', async () => {
    // Given
    const jobData = {
      id: generateMonotonicUuid(),
      value2: 'jobPayload2 test',
      metadata: { correlationId: generateMonotonicUuid() },
    }

    const jobId = await queueManager.schedule('queue2', jobData)

    const job = await processorWithSuccessHook.spy.waitForJobWithId(jobId, 'completed')
    expect(job.data).toMatchObject(jobData)

    // Then
    expect(processorWithSuccessHook.onSuccessCallsCounter).toBe(1)
  })

  it('should handle onSuccess hook error', async () => {
    const jobData = {
      id: generateMonotonicUuid(),
      value2: 'jobPayload2 test',
      metadata: { correlationId: generateMonotonicUuid() },
    }

    processorWithSuccessHook.onSuccessHook = () => {
      throw new Error('onSuccessError')
    }

    const jobId = await queueManager.schedule('queue2', jobData)

    const job = await processorWithSuccessHook.spy.waitForJobWithId(jobId, 'completed')
    expect(job.data).toMatchObject(jobData)

    // Then
    expect(processorWithSuccessHook.onSuccessCallsCounter).toBe(1)
  })

  it('should clear job data onSuccess', async () => {
    const jobData = {
      id: generateMonotonicUuid(),
      value2: 'jobPayload2 test',
      metadata: { correlationId: generateMonotonicUuid() },
    }

    processorWithSuccessHook.onSuccessHook = (job) => {
      void processorWithSuccessHook.purgeJobData(job)
    }

    await processorWithSuccessHook.start()
    const jobId = await queueManager.schedule('queue2', jobData)

    const job = await processorWithSuccessHook.spy.waitForJobWithId(jobId, 'completed')

    await processorWithSuccessHook.dispose()

    // Then
    expect(processorWithSuccessHook.onSuccessCallsCounter).toBe(1)
    expect(processorWithSuccessHook.jobDataResult).toStrictEqual({
      metadata: jobData.metadata,
    })
    expect(job.data).toStrictEqual(jobData)
    expect(processorWithSuccessHook.runningPromisesSet).toHaveLength(0)
  })

  it('ignores missing job error during data purging', async () => {
    // Given
    const jobData = {
      id: generateMonotonicUuid(),
      value2: 'jobPayload2 test',
      metadata: { correlationId: generateMonotonicUuid() },
    }

    const purgePromise = new Promise<void>((resolve) => {
      processorWithSuccessHook.onSuccessHook = async (job) => {
        // Dropping the job right before purging will cause a job deleted error during purging.
        await job.remove()
        // Run the purging. It should ignore the error and continue.
        await processorWithSuccessHook.purgeJobData(job)
        resolve()
      }
    })

    const jobId = await queueManager.schedule('queue2', jobData)

    // When
    await processorWithSuccessHook.spy.waitForJobWithId(jobId, 'completed')

    // Then
    await expect(purgePromise).resolves.not.toThrow()
    expect(processorWithSuccessHook.runningPromisesSet).toHaveLength(0)
  })

  it('throws an error if job data purge fails', async () => {
    // Given
    const jobData = {
      id: generateMonotonicUuid(),
      value2: 'jobPayload2 test',
      metadata: { correlationId: generateMonotonicUuid() },
    }

    const purgeExecutionPromise = new Promise<void>((resolve) => {
      processorWithSuccessHook.onSuccessHook = (job) => {
        const jobClearLogsSpy = vi.spyOn(job, 'clearLogs')
        jobClearLogsSpy.mockRejectedValueOnce(new Error('Simulated'))
        resolve(processorWithSuccessHook.purgeJobData(job))
      }
    })

    // When
    await queueManager.schedule('queue2', jobData)

    // Then
    await expect(purgeExecutionPromise).rejects.toThrowError(
      /Job data purge failed: {"type":"Error","message":"Simulated"/,
    )
    expect(processorWithSuccessHook.runningPromisesSet).toHaveLength(0)
  })
})
